* Week 0 - Welcome to Algorithms, Part 1

** Commented books

  - Algorithms + Data Structures = Programs
    Niklaus Wirth

  - Donald Knuth books
    http://www-cs-faculty.stanford.edu/~uno/books.html

  - Algorithms (text book of the course)
    http://algs4.cs.princeton.edu/home/

  - Introduction to Programming in Java (recommended)
    http://introcs.cs.princeton.edu/java/home/

* Week 1 - Union Find

** Dinamic Connectivity

  - A scientific approach to designing and analysing algorithms:
    1. model the problem;
    2. find an algorithm to solve it;
    3. fast enough? fits in memmory?
    4. if not, figure out why;
    5. find a way to address the problem;
    6. iterate until sitisfied.

  - `is_connected_to` is an equivalence relation (reflexive, symmetric, transitive)

  - The expected *interface* to Union Find implementations is:

    #+BEGIN_SRC java
      public interface UF {
          // add connection between p and q
          public void union(int p, int q);

          // commponent identifier for p (0 to N-1)
          public int find(int p);

          // are p and q in the same component?
          public boolean connected(int p, int q);

          // number of components
          public int count();
      }
    #+END_SRC

  - *QuickFind* is an *eager* approach to Union Find algorithm;

  - *QuickUnion* is a *lazy* approach to Union Find algorithm;

  +-------------------------------+------------+---------+------+
  |          algorithm            | initialize | union   | find |
  +-------------------------------+------------+---------+------+
  |          quick-find           |     N      |   N     |  1   |
  +-------------------------------+------------+---------+------+
  |          quick-union          |     N      |   N *   |  N   |
  +-------------------------------+------------+---------+------+
  |     weighted-quick-union      |     N      | lg N *  | lg N |
  +-------------------------------+------------+---------+------+
    * = includes cost of finding roots

  +-------------------------------+----------------------+
  |          algorithm            |   wrost-case-time    |
  +-------------------------------+----------------------+
  |          quick-find           |         M N          |
  +-------------------------------+----------------------+
  |          quick-union          |         M N          |
  +-------------------------------+----------------------+
  |     weighted-quick-union      |     N + M log N      |
  +-------------------------------+----------------------+
  |  path-compressed-quick-union  |      N + M lg N      |
  +-------------------------------+----------------------+
    * M union-find operations on a set of N objects

  - Rough standard (sinse 1950) = 10^9 (1 billion) operations per second:

    Quick-Find = 10^9 union commands * 10^9 objects
               = 10^18 operations
               = 10^9 seconds
               = 32 years of computer time

  - Path compressed weighted quick union reduces time from 32 years to 6
    seconds.

  - Supercomputer won't help much, the solution is to use good algorithms.

  - Testing standard input files:

    #+BEGIN_SRC shell-script
      gradle build
      cd build/classes/main
      input=../../../data/largeUF.txt # 2,000,000 connections

      time java QuickFind < input
      # => 6 components
      #
      # => real 58m14.662s
      # => user 58m11.808s
      # => sys  0m3.916s

      time java QuickUnion < input
      # => 6 components
      #
      # => real 318m13.572s
      # => user 318m13.192s
      # => sys  0m11.556s

      time java WeightedQuickUnion < input
      # => 6 components
      # =>
      # => real 0m3.596s
      # => user 0m4.112s
      # => sys  0m0.164s

      time java PathCompressedQuickUnion < input
      # => 6 components
      # =>
      # => real 0m3.472s
      # => user 0m3.984s
      # => sys  0m0.112s
    #+END_SRC
